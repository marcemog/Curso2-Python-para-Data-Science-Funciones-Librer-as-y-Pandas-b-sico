# -*- coding: utf-8 -*-
"""Curso2 Python para Data Science Funciones, Librerías y Pandas básico.IPY

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JbgYvmEs87_tt74ltFr5UYSMKCMDezqj

# <font color=green> PYTHON PARA DATA SCIENCE - PANDAS
---

# <font color=green> 1. INTRODUCCIÓN A PYTHON
---

# 1.1 Introducción

> Python es un lenguaje de programación de alto nivel con soporte a múltiples paradigmas de programación. Es un proyecto *open source* y desde su aparición en 1991, viene convirtiéndose en uno de los lenguajes de programación interpretados más populares. 
>
> En los últimos años Python ha desarrollado una comunidad activa de procesamiento científico y análisis de datos y viene destacándose como uno de los lenguajes más relevantes cuando el asunto es ciencia de datos y machine learning, tanto en el entorno académico como también en el entorno laboral.

# 1.2 Instalación y entorno de trabajo

### Instalación Local

### https://www.python.org/downloads/
### o
### https://www.anaconda.com/distribution/

### Google Colaboratory

### https://colab.research.google.com

### Verificando versión
"""



"""# 1.3 Trabajando con datos"""

import pandas as pd
pd.set_option('display.max_rows', 10)
pd.set_option('display.max_columns', 10)

dataset = pd.read_csv('db.csv', sep = ';')

dataset

dataset.dtypes

dataset[['Kilometraje','Valor']].describe()

dataset.info()

"""# <font color=green> 2. TRABAJANDO CON TUPLAS
---

# 2.1 Creando tuplas

Tuplas son secuencias **inmutables** que son utilizadas para guardar colecciones de objetos, geralmente heterogéneos. Pueden ser construídas de varias formas:
```
- Utilizando un par de paréntesis: ( )
- Utilizando una coma a la derecha: x,
- Utilizando un par de paréntesis con objetos separados por comas: ( x, y, z )
- Utilizando: tuple() o tuple(iterador)
```
"""

()

1, 2, 3

nombre = 'Passat'
valor = 153000
(nombre, valor)

nombres_carros = tuple(['Jetta Variant', 'Passat', 'Crossfox', 'DS5'])
nombres_carros

type(nombres_carros)

"""# 2.2 Selecciones en tuplas"""

nombres_carros = tuple(['Jetta Variant', 'Passat', 'Crossfox', 'DS5'])
nombres_carros

nombres_carros[0]

nombres_carros[1]

nombres_carros[-1]

nombres_carros[1:3]

nombres_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5', ('Fusca', 'Gol', 'C4'))
nombres_carros

nombres_carros[-1]  #tupla dentro de tupla

nombres_carros[-1][1]

"""# 2.3 Iterando en tuplas"""

nombres_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5')
nombres_carros

for item in nombres_carros:
  print(item)

"""### Desempacando tuplas"""

nombres_carros = ('Jetta Variant', 'Passat', 'Crossfox', 'DS5')
nombres_carros

carro_1, carro_2, carro_3, carro_4 = nombres_carros

carro_1

carro_2

carro_3

carro_4

_, A, _, B = nombres_carros #con el _ hago que ignore el elemento de esa posicion de la tupla, en este caso solo guarda en A el elemento de la posicion 2 y en B el elemento de la posicion 4

A

B

_, C, *_ = nombres_carros #con el * antes del _ hago que se ignoren los elementos de esa posicion en adelante

C

"""## *zip()*

https://docs.python.org/3.6/library/functions.html#zip
"""

carros = ['Jetta Variant', 'Passat', 'Crossfox', 'DS5']
carros

valores = [88078.64, 106161.94, 72832.16, 124549.07]
valores

list(zip(carros, valores))

for item in zip(carros, valores):
  print(item)

for carro, valor in zip(carros, valores):
  print(carro, valor)

for carro, valor in zip(carros, valores):
  if valor > 100000:
    print(carro)

"""# <font color=green> 3. TRABAJANDO CON DICCIONARIOS
---

# 3.1 Creando diccionarios

Listas son colecciones secuenciales, es decir, los elementos de estas secuencias están ordenados y utilizan índices (números enteros) para acceder a los valores.

Los diccionarios son colecciones ligeramente diferentes. Son estructuras de datos que representan un tipo de mapeo. Los mapeos son colecciones de asociaciones entre pares de valores donde el primer elemento del par se conoce como llave (*key*) y el segundo como valor (*value*).

```
diccionario = {key_1: value_1, key_2: value_2, ..., key_n: value_n}
```

https://docs.python.org/3.6/library/stdtypes.html#typesmapping
"""

carros = ['Jetta Variant', 'Passat', 'Crossfox']
carros

valores = [88078.64, 106161.94, 72832.16]
valores

carros.index('Passat')

valores[carros.index('Passat')]

datos = {'Jetta Variant':88078.64 , 'Passat':106161.94, 'Crossfox':72832.16}
datos

type(datos)

"""### Creando diccionarios con *zip()*"""

list(zip(carros, valores))

datos = dict(zip(carros, valores))
datos

"""# 3.2 Operaciones con diccionarios

## *dict[ key ]*

Devuelve el valor correspondiente a la llave (*key*) en el diccionario.
"""

datos['Passat']

"""## *key in dict*

Devuelve **True** si la llave (*key*) es encontrada en el diccionario.
"""

'Passat' in datos

'Fusca' in datos

'Fusca' not in datos

"""## *len(dict)*

Devuelve el número de itens del diccionario.
"""

len(datos)

"""## *dict[ key ] = value*

Incluye un item al diccionario.
"""

datos['DS5'] = 123456.43

datos

"""## *del dict[ key ]*

Borra el item de llave (*key*) del diccionario.
"""

del datos['Passat']

datos

"""# 3.3 Métodos de diccionarios

## *dict.update()*

Actualiza el diccionario.
"""

datos

datos.update({'Passat':106161.94})
datos

datos.update({'Passat':106161.95, 'Fusca':150000})
datos

"""## *dict.copy()*

Crea una copia del diccionario.
"""

datosCopy = datos.copy()

datosCopy

del datosCopy['Fusca']
datosCopy

datos

"""## *dict.pop(key[, default ])*

Si la llave se encuentra en el diccionario, el elemento se elimina y se devuelve su valor. De lo contrario, se devuelve el valor especificado como *default*. Si no se proporciona el valor *default* y la llave no se encuentra en el diccionario, se generará un error.
"""

datosCopy

datosCopy.pop('Passat')

datosCopy

datosCopy.pop('Passat')

datosCopy.pop('Passat', 'Llave no encontrada')

datosCopy.pop('DS5', 'Llave no encontrada')

datosCopy

"""## *dict.clear()*

Borra todos los itens del diccionario.
"""

datosCopy.clear()

datosCopy

"""# 3.4 Iterando en diccionarios

## *dict.keys()*

Devuelve una lista con las llaves (*keys*) del diccionario.
"""

datos.keys()

for key in datos.keys():
  print (key)

"""## *dict.values()*

Devuelve una lista con todos los valores (*values*) del diccionario.
"""

datos.values()

"""## *dict.items()*

Devuelve una lista con una tupla para cada par llave-valor (*key-value*) del diccionario.
"""

datos.items()

for item in datos.items():
  print(item)

for key, value in datos.items():
  print(key, '->', value)

for key, value in datos.items():
  if value > 100000:
    print(key)

"""# <font color=green> 4. FUNCIONES Y PAQUETES
---

Funciones son unidades de código reutilizables que realizan una tarea específica, pueden recibir alguna entrada y también pueden devolver algún resultado.

# 4.1 Built-in function

El lenguaje Python tiene varias funciones integradas que siempre están accesibles. Algunas ya las usamos en nuestro entrenamiento:
type(), print(), zip(), len(), set() etc.

https://docs.python.org/3.6/library/functions.html
"""

datos = {'Jetta Variant': 88078.64, 'Passat': 106161.94, 'Crossfox': 72832.16}
datos

valores = []
for valor in datos.values():
  valores.append(valor)
valores

suma = 0
for valor in datos.values():
  suma += valor
suma

list(datos.values())

sum(datos.values())

help(print)

print?

"""# 4.2 Definiendo funciones sin y con parámetros

### Funciones sin parámetros

#### Formato estándar

```
def <nombre>():
    <instrucciones>
```
"""

def media():
  valor = (1+2+3)/3
  print(valor)

media()

"""### Funciones con parámetros

#### Formato estándar

```
def <nombre>(<param_1>, <param_2>, ..., <param_n>):
    <instrucciones>
```
"""

def media(n1,n2,n3):
  valor = (n1+n2+n3)/3
  print(valor)

media(1,2,3)

media(23,45,67)

def media(lista):
  valor = sum(lista)/ len(lista)
  print(valor)

resultado = media([1,2,3,4,5,6,7,8])

resultado

type(resultado)

"""# 4.3 Definiendo funciones que devuelven valores

### Funciones que devuelven un valor

#### Formato estándar

```
def <nombre>(<param_1>, <param_2>, ..., <param_n>):
    <instrucciones>
    return <resultado>
```
"""

def media(lista):
  valor = sum(lista)/ len(lista)
  return (valor)

media([1,2,3,4,5,6,7,8])

resultado = media([1,2,3,4,5,6,7,8])

resultado

"""### Funciones que devuelven más de un valor

#### Formato estándar

```
def <nombre>(<param_1>, <param_2>, ..., <param_n>):
    <instrucciones>
    return (<resultado_1>, <resultado_2>, ..., <resultado_n>)
```
"""

def media(lista):
  valor = sum(lista)/ len(lista)
  return (valor, len(lista))

media([1,2,3,4,5,6,7,8])

resultado, n = media([1,2,3,4,5,6,7,8])

resultado

n

"""# <font color=green> 5. PANDAS BÁSICO
---

**versión: 1.1.0**

Pandas es una herramienta de manipulación de datos de alto nivel, construida sobre la base del paquete Numpy. El paquete pandas tiene estructuras de datos muy interesantes para la manipulación de datos y, por esto, es ampliamente utilizado por los científicos de datos.


## Estructuras de Datos

### Series

Series son arrays unidimensionales etiquetados capaces de almacenar cualquier tipo de dato. Las etiquetas de las líneas se denominan **index**. La forma básica de crear una Series es la siguiente:


```
    s = pd.Series(datos, index = index)
```

El argumento *datos* puede ser un diccionario, una lista, un array Numpy o una constante.

### DataFrames

DataFrame es una estructura de datos tabular bidimensional con etiquetas de fila y columna. Como la Series, los DataFrames son capaces de almacenar cualquier tipo de datos.


```
    df = pd.DataFrame(datos, index = index, columns = columns)
```

El argumento *datos* puede ser un diccionario, una lista, un array Numpy, una Series y otro DataFrame.

**Documentación:** https://pandas.pydata.org/pandas-docs/version/1.1.0/

# 5.1 Estructuras de datos
"""

import pandas as pd

"""### Creando una Series a partir de una lista"""

carros = ['Jetta Variant', 'Passat', 'Crossfox']
carros

pd.Series(carros)

"""### Creando un DataFrame a partir de una lista de diccionarios"""

datos = [
    {'Nombre': 'Jetta Variant', 'Motor': 'Motor 4.0 Turbo', 'Año': 2003, 'Kilometraje': 44410.0, 'Cero_km': False, 'Valor': 88078.64},
    {'Nombre': 'Passat', 'Motor': 'Motor Diesel', 'Año': 1991, 'Kilometraje': 5712.0, 'Cero_km': False, 'Valor': 106161.94},
    {'Nombre': 'Crossfox', 'Motor': 'Motor Diesel V8', 'Año': 1990, 'Kilometraje': 37123.0, 'Cero_km': False, 'Valor': 72832.16}
]

dataset = pd.DataFrame(datos)

dataset

dataset[['Nombre','Año', 'Kilometraje', 'Motor', 'Cero_km', 'Valor']]

"""### Creando un DataFrame a partir de un diccionario"""

datos = {
    'Nombre': ['Jetta Variant', 'Passat', 'Crossfox'], 
    'Motor': ['Motor 4.0 Turbo', 'Motor Diesel', 'Motor Diesel V8'],
    'Año': [2003, 1991, 1990],
    'Kilometraje': [44410.0, 5712.0, 37123.0],
    'Cero_km': [False, False, False],
    'Valor': [88078.64, 106161.94, 72832.16]
}

dataset = pd.DataFrame(datos)

dataset

"""### Creando un DataFrame a partir de un archivo externo"""

dataset = pd.read_csv('db.csv', sep = ';', index_col = 0)

dataset

"""# 5.2 Selecciones con DataFrames

### Seleccionando columnas
"""

dataset.head()

dataset['Valor']

type(dataset['Valor'])

dataset[['Valor']]

type(dataset[['Valor']])

"""### Seleccionando lineas - [ i : j ] 

<font color=red>**Observación:**</font> La indexación tiene origen en cero y en las particiones(*slices*) la línea con índice i es **incluída** y la línea con índice j **no es incluída** en el resultado.
"""

dataset[0:3]

"""### Utilizando .loc para selecciones

<font color=red>**Observación:**</font> Selecciona un grupo de líneas y columnas según las etiquetas o una matriz booleana.
"""

dataset.loc['Passat'] #el resultado viene en formato de series porque tiene un par de corchetes, si quiero en data frame hay que poner doble par de corchetes

dataset.loc[['Passat', 'DS5']] #al buscar con dos argumentos si o si hay que usar doble corchete para que salga en formato de data frame, de lo contraio al usar un solo par tira error

dataset.loc[['Passat', 'DS5'],['Motor', 'Valor']]

dataset.loc[:, ['Motor', 'Valor']]

"""### Utilizando .iloc para selecciones

<font color=red>**Observación:**</font> Selecciona con base en los índices, es decir, utiliza la posición de las informaciones.
"""

dataset.head()

dataset.iloc[[1]]

dataset.iloc[1:4] #al usar un intervalo va con un solo par de corchetes

dataset.iloc[1:4, [0, 5, 2]]

dataset.iloc[[1, 42, 22], [0, 5, 2]]

dataset.iloc[:, [0, 5, 2]]

"""# 5.3 Consultas en DataFrames"""

dataset.head()

dataset.Motor

dataset.Motor == 'Motor Diesel'

type(dataset.Motor == 'Motor Diesel')

dataset[dataset.Motor == 'Motor Diesel']

dataset[(dataset.Motor == 'Motor Diesel') & (dataset.Cero_km	== True)]

"""### Utilizando el método query"""

dataset.query('Motor == "Motor Diesel" and Cero_km == True')

"""# 5.4 Iterando con DataFrames"""

dataset.head()

for item in dataset:
  print(item)

list(dataset.iterrows())

for index, row in dataset.iterrows():
  if(2019 - row.Año != 0):
    dataset.loc[index, 'km_media'] = row.Kilometraje / (2019 - row.Año)
  else:
    dataset.loc[index, 'km_media'] = 0

dataset

list(dataset.itertuples())

list(dataset.items())

"""# 5.5 Tratamiento de datos"""

dataset.head()

dataset.info()

dataset.Kilometraje.isna()

dataset[dataset.Kilometraje.isna()]

dataset.fillna(0)

dataset

dataset.fillna(0, inplace = True) #modifica el dataset y sustituye el NaN por 0 en este caso porque son todos los autos con 0km los que tienen NaN em kilometraje

dataset

dataset.query('Cero_km == True')

dataset = pd.read_csv('db.csv', sep = ';')

dataset

dataset.dropna(subset = ['Kilometraje'], inplace = True) #elimino las filas donde el valor de kilometraje en NaN, con el inplace me aseguro de eliminarlos del dataset y no solo de la visualizacion como ocurriria si no lo pongo

dataset

